import os
import shutil
import zipfile
import tempfile
import json
import argparse
from contextlib import contextmanager

from tqdm import tqdm

from minecraft_server_tools import sync_mods, launch_server
from minecraft_server_tools.constants import (
    WINDOWS,
    SERVER_DIR,
    MINECRAFT_DIR,
    EXTRA_INSTALL_FOLDERS,
    EXTRA_INSTALL_FILES,
    FORGE_INSTALLER_JAR,
    README_FILE,
    MOD_ZIP_PATH,
    ALT_MOD_ZIP_PATH,
    OPTIONAL_INSTALL_FILES,
    OPTIONAL_INSTALL_FOLDERS,
    MODS_NAME,
    CLIENT_MODS_NAME,
    YES_STRS,
    NO_STRS,
    PROFILES_FILE,
    MODPACK_NAME,
    START_ARGS,
    LAUNCHER_FILE,
    BARREL_ROLL_MOD_PREFIX,
    FORGE_PROFILE_NAME,
    USE_GRAAL,
    fixpath,
)

MINECRAFT_MODS_DIR = os.path.join(MINECRAFT_DIR, MODS_NAME)


def sync_client_mods(source_dir, do_barrel_roll=True):
    print("\nInstalling mods...")
    all_client_mods = sync_mods.get_location_table_for(os.path.join(source_dir, MODS_NAME))
    all_client_mods.update(sync_mods.get_location_table_for(os.path.join(source_dir, CLIENT_MODS_NAME)))

    if do_barrel_roll is False:
        barrel_roll_mods = all_client_mods |> filter$(.startswith(BARREL_ROLL_MOD_PREFIX)) |> tuple
        for barrel_roll_mod_name in barrel_roll_mods:
            print(f"\tSkipping {barrel_roll_mod_name!r} (not doing a barrel roll)...")
            del all_client_mods[barrel_roll_mod_name]

    current_client_mods = sync_mods.get_location_table_for(MINECRAFT_MODS_DIR)

    sync_mods.set_mods_from_to(all_client_mods, current_client_mods, MINECRAFT_MODS_DIR)


def install_extras(source_dir, do_optional=True, clean=True):
    print("\nInstalling other files/folders...")

    if not do_optional:
        optional_rel_paths = {p.replace("\\", "/") for p in OPTIONAL_INSTALL_FOLDERS + OPTIONAL_INSTALL_FILES}
        def ignore_optional(directory, contents):
            ignored = set()
            for name in contents:
                rel_path = os.path.relpath(os.path.join(directory, name), source_dir).replace("\\", "/")
                if rel_path in optional_rel_paths:
                    print(f"\t\tskipping optional {rel_path}")
                    ignored.add(name)
            return ignored
    else:
        optional_rel_paths = set()
        ignore_optional = None

    for install_dir in EXTRA_INSTALL_FOLDERS:
        from_dir = os.path.join(source_dir, install_dir)
        to_dir = os.path.join(MINECRAFT_DIR, install_dir)
        print(f"\t{install_dir}...")
        cleaned = False
        if clean and os.path.exists(to_dir):
            launch_server.remove_dir_if_exists(to_dir)
            cleaned = True
        if os.path.exists(from_dir):
            shutil.copytree(from_dir, to_dir, dirs_exist_ok=True, ignore=ignore_optional)
        elif cleaned:
            print("\t\t(cleaned)")
        else:
            print("\t\t(skipped)")

    for install_dir in OPTIONAL_INSTALL_FOLDERS:
        from_dir = os.path.join(source_dir, install_dir)
        to_dir = os.path.join(MINECRAFT_DIR, install_dir)
        if do_optional:
            print(f"\t{install_dir}...")
            cleaned = False
            if clean and os.path.exists(to_dir):
                launch_server.remove_dir_if_exists(to_dir)
                cleaned = True
            if os.path.exists(from_dir):
                shutil.copytree(from_dir, to_dir, dirs_exist_ok=True)
            elif cleaned:
                print("\t\t(cleaned)")
            else:
                print("\t\t(skipped)")
        elif not os.path.exists(to_dir):
            print(f"\t{install_dir} (missing, installing)...")
            if os.path.exists(from_dir):
                shutil.copytree(from_dir, to_dir, dirs_exist_ok=True)
            else:
                print("\t\t(skipped)")

    for install_file in EXTRA_INSTALL_FILES:
        from_path = os.path.join(source_dir, install_file)
        to_path = os.path.join(MINECRAFT_DIR, install_file)
        if install_file.replace("\\", "/") in optional_rel_paths:
            print(f"\t{install_file} skipped as optional")
            continue
        print(f"\t{install_file}...")
        if os.path.exists(from_path):
            shutil.copy(from_path, to_path)
        else:
            print("\t\t(skipped)")

    for install_file in OPTIONAL_INSTALL_FILES:
        from_path = os.path.join(source_dir, install_file)
        to_path = os.path.join(MINECRAFT_DIR, install_file)
        if do_optional or not os.path.exists(to_path):
            if not do_optional:
                print(f"\t{install_file} (missing, installing)...")
            else:
                print(f"\t{install_file}...")
            if os.path.exists(from_path):
                shutil.copy(from_path, to_path)
            else:
                print("\t\t(skipped)")


def ensure_forge_client(source_dir, force=False):
    if force or not os.path.exists(os.path.join(MINECRAFT_DIR, FORGE_INSTALLER_JAR)):
        launch_server.ensure_graal()
        print("\nOpening forge installer; select 'Install client' and press 'Proceed'.")
        launch_server.run_java(["-jar", os.path.join(source_dir, FORGE_INSTALLER_JAR)])


def get_paths_to_zip():
    for install_fname in (
        EXTRA_INSTALL_FILES
        + OPTIONAL_INSTALL_FILES
    ):
        fpath = os.path.join(MINECRAFT_DIR, install_fname)
        if os.path.exists(fpath):
            yield fpath
        else:
            print(f"\tSkipped {fpath!r}...")
    for install_dirname in (
        EXTRA_INSTALL_FOLDERS
        + OPTIONAL_INSTALL_FOLDERS
        + [MODS_NAME]
    ):
        install_dirpath = os.path.join(MINECRAFT_DIR, install_dirname)
        for dirpath, dirnames, filenames in os.walk(install_dirpath):
            yield dirpath
            for fname in filenames:
                yield os.path.join(dirpath, fname)


def zip_mods():
    print(f"\nZipping mod files to {MOD_ZIP_PATH}...")
    with zipfile.ZipFile(MOD_ZIP_PATH, "w", zipfile.ZIP_DEFLATED) as zf:
        for install_path in tqdm(list(get_paths_to_zip())):
            zf.write(install_path, os.path.relpath(install_path, MINECRAFT_DIR))
    if ALT_MOD_ZIP_PATH is not None:
        print(f"\tCopying {MOD_ZIP_PATH!r} to {ALT_MOD_ZIP_PATH!r}...")
        shutil.copy(MOD_ZIP_PATH, ALT_MOD_ZIP_PATH)


def get_javaw_path():
    if USE_GRAAL:
        graal_bin_dir = launch_server.get_graal_bin_dir()
        javaw_path = os.path.join(graal_bin_dir, "javaw.exe" if WINDOWS else "javaw")
        if os.path.exists(javaw_path):
            return javaw_path
    for where_cmd in ("which", "where"):
        try:
            paths = launch_server.get_cmd_output([where_cmd, "javaw"])
        except FileNotFoundError:
            pass
        else:
            break
    else:
        return None
    path = (
        paths
        |> .splitlines()
        |> .$[0]
        |> .strip()
    )
    if WINDOWS and not path.endswith(".exe"):
        path += ".exe"
        if path.startswith("/c/"):
            path = "C:" + path[2:]
        elif path.startswith("c/"):
            path = "C:" + path[1:]
    return fixpath(path)


def set_jvm_args():
    print("\nSetting JVM arguments...")
    with launch_server.using_graal_java():
        java_args = " ".join(launch_server.get_java_args(client=True))
        java_path = get_javaw_path()
        with open(PROFILES_FILE, "r+") as profiles_file:
            top_level_json = json.load(profiles_file)
            profiles = top_level_json["profiles"]
            if FORGE_PROFILE_NAME not in profiles:
                return False
            forge_profile = profiles[FORGE_PROFILE_NAME]
            forge_profile["name"] = MODPACK_NAME
            forge_profile["javaArgs"] = java_args
            if java_path:
                print(f"\t(using java at: {java_path!r})")
                forge_profile["javaDir"] = java_path
            else:
                print("\t(failed to locate java)")

            profiles_file.seek(0)
            profiles_file.truncate()
            json.dump(top_level_json, profiles_file, indent=2)
    return True


def open_readme():
    installed_readme = os.path.join(MINECRAFT_DIR, README_FILE)
    print(f"\nOpening {installed_readme}...")
    if WINDOWS:
        launch_server.run_cmd(["explorer", installed_readme], check=False)
    else:
        launch_server.run_cmd(["xdg-open", installed_readme], check=False)


@contextmanager
def unzipped_mods():
    with tempfile.TemporaryDirectory() as temp_dir:
        print(f"\nUnzipping mods from {MOD_ZIP_PATH!r} to temporary directory {temp_dir!r}...")
        shutil.unpack_archive(MOD_ZIP_PATH, temp_dir)
        yield temp_dir


def install_from_dir(source_dir, do_optional=False, do_barrel_roll=True, no_mods=False, no_files=False):
    launch_server.clean_forge_jars(MINECRAFT_DIR)

    ensure_forge_client(source_dir)
    success = set_jvm_args()
    if not success:
        ensure_forge_client(source_dir, force=True)
        if not set_jvm_args():
            raise OSError(f"Failed to automatically install forge; you'll need to run {FORGE_INSTALLER_JAR} manually.")

    if not no_mods:
        sync_client_mods(source_dir, do_barrel_roll)
    if not no_files:
        install_extras(source_dir, do_optional)


def install_from_server(no_mods=False, no_files=False, no_zip=False):
    """Install from server and return whether or not to install optional files."""
    sync_mods.main()
    launch_server.start_server(dry_run=True)

    install_from_dir(SERVER_DIR, do_optional=True, no_mods=no_mods, no_files=no_files)

    if not (no_zip or no_mods or no_files):
        zip_mods()
    return True, True


def ask_question(text, default):
    got = input(text).lower()
    if got in YES_STRS:
        return True
    elif got in NO_STRS:
        return False
    else:
        return default


def install_from_zip(optional=None, barrel_roll=None, no_mods=False, no_files=False):
    """Install from zip and return whether or not to install optional files."""
    if optional is True:
        do_optional = True
    elif optional is False:
        do_optional = False
    else:
        do_optional = ask_question(f"\nOverwrite optional files {OPTIONAL_INSTALL_FILES + OPTIONAL_INSTALL_FOLDERS}? [Y/n] ", True)
    if do_optional:
        print("Will overwrite optional files.")
    else:
        print("Will NOT overwrite optional files.")

    if BARREL_ROLL_MOD_PREFIX is None:
        do_barrel_roll = None
    elif barrel_roll is True:
        do_barrel_roll = True
    elif barrel_roll is False:
        do_barrel_roll = False
    else:
        do_barrel_roll = ask_question("\nDo a barrel roll? [Y/n] ", True)
    if do_barrel_roll:
        print("Will do a barrel roll.")
    else:
        print("Will NOT do a barrel roll.")

    with unzipped_mods() as temp_dir:
        install_from_dir(temp_dir, do_optional=do_optional, do_barrel_roll=do_barrel_roll, no_mods=no_mods, no_files=no_files)
    return do_optional, do_barrel_roll


def launch_minecraft():
    print(f"\nLaunching Minecraft at {LAUNCHER_FILE!r}...")
    if not os.path.exists(LAUNCHER_FILE):
        raise OSError("Could not find Minecraft Launcher file!\n\nMod files have still been installed, but you'll need to launch Minecraft manually.")
    if WINDOWS:
        launch_server.run_cmd(["START", MODPACK_NAME] + START_ARGS + [LAUNCHER_FILE], shell=True)
    else:
        launch_server.run_cmd(["open", LAUNCHER_FILE])


def parse_args():
    parser = argparse.ArgumentParser(
        description="Install Minecraft client with mods and configuration files.",
    )
    parser.add_argument(
        "--launch",
        action="store_true",
        help="Launch Minecraft after installation",
    )
    parser.add_argument(
        "--no-mods",
        action="store_true",
        help="Skip installing mods",
    )
    parser.add_argument(
        "--no-files",
        action="store_true",
        help="Skip installing extra files and folders",
    )
    parser.add_argument(
        "--no-zip",
        action="store_true",
        help="Skip zipping mods after server install",
    )

    optional_group = parser.add_mutually_exclusive_group()
    optional_group.add_argument(
        "--yes-optional",
        action="store_true",
        help="Overwrite optional files without prompting",
    )
    optional_group.add_argument(
        "--no-optional",
        action="store_true",
        help="Skip optional files without prompting",
    )

    barrel_roll_group = parser.add_mutually_exclusive_group()
    barrel_roll_group.add_argument(
        "--yes-barrel-roll",
        action="store_true",
        help="Install barrel roll mod without prompting",
    )
    barrel_roll_group.add_argument(
        "--no-barrel-roll",
        action="store_true",
        help="Skip barrel roll mod without prompting",
    )

    return parser.parse_args()


def main():
    args = parse_args()

    # Convert mutually exclusive groups to tri-state values
    optional = True if args.yes_optional else (False if args.no_optional else None)
    barrel_roll = True if args.yes_barrel_roll else (False if args.no_barrel_roll else None)

    if os.path.exists(SERVER_DIR):
        print("\nInstalling from server...")
        do_optional, do_barrel_roll = install_from_server(
            no_mods=args.no_mods,
            no_files=args.no_files,
            no_zip=args.no_zip,
        )
    elif os.path.exists(MOD_ZIP_PATH):
        if "downloads" in MOD_ZIP_PATH.lower():
            print("WARNING: Using downloaded Minecraft Mods.zip instead of synchronized version; you will not get updates automatically.")
        print("\nInstalling from zipfile...")
        do_optional, do_barrel_roll = install_from_zip(
            optional=optional,
            barrel_roll=barrel_roll,
            no_mods=args.no_mods,
            no_files=args.no_files,
        )
    else:
        raise IOError("Could not find files for install (make sure you have the 'Minecraft Mods' folder in your OneDrive/Dropbox).")

    if args.launch:
        launch_minecraft()
    return do_optional, do_barrel_roll


if __name__ == "__main__":
    main()
