"""Entry point to commit or revert pending mod/datapack updates.

After update_mods.coco runs, it creates:
- {mods_dir}-updates: Contains newly downloaded mod/datapack versions
- {mods_dir}-old: Contains old mod/datapack versions that were replaced

This script allows you to either:
- commit: Move updates into the main folders (keeping new versions)
- revert: Move old versions back into main folders (reverting to old versions)

In either case, the -updates and -old folders are deleted afterward.
"""
import os
import shutil
import argparse

from minecraft_server_tools.constants import (
    UPDATED_MODS_DIR_SUFFIX,
    OLD_MODS_DIR_SUFFIX,
)
from minecraft_server_tools.update_mods import UPDATE_MODS_DIRS, UPDATE_DATAPACK_DIRS
from minecraft_server_tools.sync_mods import get_location_table_for, display_mod_path
from minecraft_server_tools.launch_server import remove_dir_if_exists

# Combined list of all directories to check for pending updates
ALL_UPDATE_DIRS = UPDATE_MODS_DIRS + UPDATE_DATAPACK_DIRS


def get_update_dirs(mods_dir):
    """Return (updates_dir, old_dir) paths for a given mods directory."""
    return (
        mods_dir + UPDATED_MODS_DIR_SUFFIX,
        mods_dir + OLD_MODS_DIR_SUFFIX,
    )


def has_pending_updates(mods_dir):
    """Check if a mods directory has pending update directories (even if empty)."""
    updates_dir, old_dir = get_update_dirs(mods_dir)
    return os.path.exists(updates_dir) or os.path.exists(old_dir)


def any_pending_dirs():
    """Check if any mods/datapack directory has pending update directories."""
    return any(has_pending_updates(d) for d in ALL_UPDATE_DIRS)


def move_mod(from_path, to_path):
    """Move a single file with nice printing."""
    print("  Moving {mod} from {src}...".format(
        mod=display_mod_path(to_path),
        src=display_mod_path(from_path),
    ))
    os.makedirs(os.path.dirname(to_path), exist_ok=True)
    if os.path.exists(to_path):
        os.remove(to_path)
    shutil.move(from_path, to_path)


def move_mods_from_to(source_table, dest_dir):
    """Move all files from source locations to dest_dir."""
    dest_table = get_location_table_for(dest_dir)
    for name, src_path in source_table.items():
        new_path = os.path.join(dest_dir, name)
        if name in dest_table:
            print(f"  Overwriting: {name}")
            os.remove(dest_table[name])
        move_mod(src_path, new_path)


def show_pending_updates():
    """Show all pending updates across all mods/datapack directories."""
    has_any = False
    for mods_dir in ALL_UPDATE_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)
        updates_table = get_location_table_for(updates_dir)
        old_table = get_location_table_for(old_dir)

        if updates_table or old_table:
            has_any = True
            dir_name = os.path.basename(mods_dir)
            print(f"\n{dir_name}:")
            if updates_table:
                print(f"  New versions ({len(updates_table)} files):")
                for f in sorted(updates_table.keys()):
                    print(f"    + {f}")
            if old_table:
                print(f"  Old versions ({len(old_table)} files):")
                for f in sorted(old_table.keys()):
                    print(f"    - {f}")

    if not has_any:
        print("No pending updates found.")
    return has_any


def commit_updates():
    """Commit all pending updates by moving new versions into main folders."""
    print("\nCommitting updates...")

    for mods_dir in ALL_UPDATE_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from updates into the main folder
        updates_table = get_location_table_for(updates_dir)
        if updates_table:
            move_mods_from_to(updates_table, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates committed successfully.")


def revert_updates():
    """Revert all pending updates by restoring old versions into main folders."""
    print("\nReverting updates (reverting to old versions)...")

    for mods_dir in ALL_UPDATE_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from old back into the main folder
        old_table = get_location_table_for(old_dir)
        if old_table:
            move_mods_from_to(old_table, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates reverted successfully (reverted to old versions).")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Commit or revert pending mod/datapack updates.",
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    subparsers.add_parser(
        "status",
        help="Show pending updates",
    )
    subparsers.add_parser(
        "commit",
        help="Apply updates (keep new versions)",
    )
    subparsers.add_parser(
        "revert",
        help="Discard updates (revert to old versions)",
    )

    return parser.parse_args()


def main():
    args = parse_args()

    if args.command is None or args.command == "status":
        show_pending_updates()
    elif args.command == "commit":
        has_files = show_pending_updates()
        if has_files or any_pending_dirs():
            print()
            commit_updates()
    elif args.command == "revert":
        has_files = show_pending_updates()
        if has_files or any_pending_dirs():
            print()
            revert_updates()


if __name__ == "__main__":
    main()
