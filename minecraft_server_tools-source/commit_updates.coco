"""Entry point to commit or revert pending mod/datapack updates.

After update_mods.coco runs, it creates:
- {mods_dir}-updates: Contains newly downloaded mod/datapack versions
- {mods_dir}-old: Contains old mod/datapack versions that were replaced

This script allows you to either:
- commit: Move updates into the main folders (keeping new versions)
- revert: Move old versions back into main folders (reverting to old versions)

In either case, the -updates and -old folders are deleted afterward.
"""
import os
import sys
import shutil
import argparse
import time
import subprocess

from minecraft_server_tools.constants import (
    UPDATED_MODS_DIR_SUFFIX,
    OLD_MODS_DIR_SUFFIX,
)
from minecraft_server_tools.update_mods import UPDATE_MODS_DIRS, UPDATE_DATAPACK_DIRS
from minecraft_server_tools.sync_mods import get_location_table_for, display_mod_path

# Combined list of all directories to check for pending updates
ALL_UPDATE_DIRS = UPDATE_MODS_DIRS + UPDATE_DATAPACK_DIRS


def get_update_dirs(mods_dir):
    """Return (updates_dir, old_dir) paths for a given mods directory."""
    return (
        mods_dir + UPDATED_MODS_DIR_SUFFIX,
        mods_dir + OLD_MODS_DIR_SUFFIX,
    )


def has_pending_updates(mods_dir):
    """Check if a mods directory has pending update directories (even if empty)."""
    updates_dir, old_dir = get_update_dirs(mods_dir)
    return os.path.exists(updates_dir) or os.path.exists(old_dir)


def any_pending_dirs():
    """Check if any mods/datapack directory has pending update directories."""
    return any(has_pending_updates(d) for d in ALL_UPDATE_DIRS)


def move_mod(from_path, to_path):
    """Move a single file with nice printing."""
    print("  Moving {mod} from {src}...".format(
        mod=display_mod_path(to_path),
        src=display_mod_path(from_path),
    ))
    os.makedirs(os.path.dirname(to_path), exist_ok=True)
    if os.path.exists(to_path):
        os.remove(to_path)
    shutil.move(from_path, to_path)


def move_mods_from_to(source_table, dest_dir):
    """Move all files from source locations to dest_dir."""
    dest_table = get_location_table_for(dest_dir)
    for name, src_path in source_table.items():
        new_path = os.path.join(dest_dir, name)
        if name in dest_table:
            print(f"  Overwriting: {name}")
            os.remove(dest_table[name])
        move_mod(src_path, new_path)


def remove_file_with_retry(filepath, max_retries=5, initial_delay=0.2):
    """Remove a single file with retry logic for Windows file locking."""
    delay = initial_delay
    for attempt in range(max_retries):
        try:
            os.remove(filepath)
            return True
        except PermissionError:
            if attempt < max_retries - 1:
                time.sleep(delay)
                delay *= 2
    return False


def remove_dir_if_exists(directory, max_retries=5, initial_delay=0.1):
    """Remove a directory if it exists.

    Uses a multi-strategy approach for Windows/OneDrive file locking:
    1. Remove all files individually with retries
    2. Try os.rmdir() for the empty directory
    3. Fall back to Windows rmdir command if needed
    4. Retry with exponential backoff
    """
    if not os.path.exists(directory):
        return

    dir_name = os.path.basename(directory)

    # First, remove all files individually
    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        if os.path.isfile(filepath):
            if not remove_file_with_retry(filepath):
                print(f"  Warning: Could not remove file {filename}")

    # Now try to remove the empty directory with retries
    delay = initial_delay
    for attempt in range(max_retries):
        try:
            # Check if directory is empty
            remaining = os.listdir(directory)
            if remaining:
                print(f"  Warning: Directory {dir_name} not empty: {remaining}")
                return

            os.rmdir(directory)
            print(f"  Removed directory: {dir_name}")
            return
        except PermissionError:
            # On Windows, try using rmdir command as fallback
            if sys.platform == "win32" and attempt == max_retries // 2:
                try:
                    subprocess.run(
                        ["cmd", "/c", "rmdir", "/s", "/q", directory],
                        check=True,
                        capture_output=True,
                    )
                    if not os.path.exists(directory):
                        print(f"  Removed directory: {dir_name} (via rmdir)")
                        return
                except subprocess.CalledProcessError:
                    pass

            if attempt < max_retries - 1:
                time.sleep(delay)
                delay = min(delay * 1.5, 5.0)  # cap at 5 seconds
            else:
                print(f"  Warning: Could not remove {dir_name} - may be locked by OneDrive")
        except OSError as e:
            if attempt < max_retries - 1:
                time.sleep(delay)
                delay = min(delay * 1.5, 5.0)
            else:
                print(f"  Warning: Could not remove {dir_name}: {e}")


def show_pending_updates():
    """Show all pending updates across all mods/datapack directories."""
    has_any = False
    for mods_dir in ALL_UPDATE_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)
        updates_table = get_location_table_for(updates_dir)
        old_table = get_location_table_for(old_dir)

        if updates_table or old_table:
            has_any = True
            dir_name = os.path.basename(mods_dir)
            print(f"\n{dir_name}:")
            if updates_table:
                print(f"  New versions ({len(updates_table)} files):")
                for f in sorted(updates_table.keys()):
                    print(f"    + {f}")
            if old_table:
                print(f"  Old versions ({len(old_table)} files):")
                for f in sorted(old_table.keys()):
                    print(f"    - {f}")

    if not has_any:
        print("No pending updates found.")
    return has_any


def commit_updates():
    """Commit all pending updates by moving new versions into main folders."""
    print("\nCommitting updates...")

    for mods_dir in ALL_UPDATE_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from updates into the main folder
        updates_table = get_location_table_for(updates_dir)
        if updates_table:
            move_mods_from_to(updates_table, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates committed successfully.")


def revert_updates():
    """Revert all pending updates by restoring old versions into main folders."""
    print("\nReverting updates (reverting to old versions)...")

    for mods_dir in ALL_UPDATE_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from old back into the main folder
        old_table = get_location_table_for(old_dir)
        if old_table:
            move_mods_from_to(old_table, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates reverted successfully (reverted to old versions).")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Commit or revert pending mod/datapack updates.",
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    subparsers.add_parser(
        "status",
        help="Show pending updates",
    )
    subparsers.add_parser(
        "commit",
        help="Apply updates (keep new versions)",
    )
    subparsers.add_parser(
        "revert",
        help="Discard updates (revert to old versions)",
    )

    return parser.parse_args()


def main():
    args = parse_args()

    if args.command is None or args.command == "status":
        show_pending_updates()
    elif args.command == "commit":
        has_files = show_pending_updates()
        if has_files or any_pending_dirs():
            print()
            commit_updates()
    elif args.command == "revert":
        has_files = show_pending_updates()
        if has_files or any_pending_dirs():
            print()
            revert_updates()


if __name__ == "__main__":
    main()
