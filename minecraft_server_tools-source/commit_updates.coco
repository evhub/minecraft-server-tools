"""Entry point to commit or revert pending mod updates.

After update_mods.coco runs, it creates:
- {mods_dir}-updates: Contains newly downloaded mod versions
- {mods_dir}-old: Contains old mod versions that were replaced

This script allows you to either:
- commit: Move updates into the main folders (keeping new versions)
- revert: Move old versions back into main folders (reverting to old versions)

In either case, the -updates and -old folders are deleted afterward.
"""
import os
import sys
import shutil
import argparse
import time
import subprocess

from minecraft_server_tools.constants import (
    UPDATED_MODS_DIR_SUFFIX,
    OLD_MODS_DIR_SUFFIX,
)
from minecraft_server_tools.update_mods import UPDATE_MODS_DIRS


def get_update_dirs(mods_dir):
    """Return (updates_dir, old_dir) paths for a given mods directory."""
    return (
        mods_dir + UPDATED_MODS_DIR_SUFFIX,
        mods_dir + OLD_MODS_DIR_SUFFIX,
    )


def has_pending_updates(mods_dir):
    """Check if a mods directory has pending update directories (even if empty)."""
    updates_dir, old_dir = get_update_dirs(mods_dir)
    return os.path.exists(updates_dir) or os.path.exists(old_dir)


def any_pending_dirs():
    """Check if any mods directory has pending update directories."""
    return any(has_pending_updates(d) for d in UPDATE_MODS_DIRS)


def list_files(directory):
    """List all files in a directory."""
    if not os.path.exists(directory):
        return []
    return [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]


def move_files(src_dir, dst_dir):
    """Move all files from src_dir to dst_dir."""
    if not os.path.exists(src_dir):
        return
    for filename in list_files(src_dir):
        src_path = os.path.join(src_dir, filename)
        dst_path = os.path.join(dst_dir, filename)
        if os.path.exists(dst_path):
            print(f"  Overwriting: {filename}")
            os.remove(dst_path)
        else:
            print(f"  Moving: {filename}")
        shutil.move(src_path, dst_path)


def remove_file_with_retry(filepath, max_retries=5, initial_delay=0.2):
    """Remove a single file with retry logic for Windows file locking."""
    delay = initial_delay
    for attempt in range(max_retries):
        try:
            os.remove(filepath)
            return True
        except PermissionError:
            if attempt < max_retries - 1:
                time.sleep(delay)
                delay *= 2
    return False


def remove_dir_if_exists(directory, max_retries=10, initial_delay=0.5):
    """Remove a directory if it exists.

    Uses a multi-strategy approach for Windows/OneDrive file locking:
    1. Remove all files individually with retries
    2. Try os.rmdir() for the empty directory
    3. Fall back to Windows rmdir command if needed
    4. Retry with exponential backoff
    """
    if not os.path.exists(directory):
        return

    dir_name = os.path.basename(directory)

    # First, remove all files individually
    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        if os.path.isfile(filepath):
            if not remove_file_with_retry(filepath):
                print(f"  Warning: Could not remove file {filename}")

    # Now try to remove the empty directory with retries
    delay = initial_delay
    for attempt in range(max_retries):
        try:
            # Check if directory is empty
            remaining = os.listdir(directory)
            if remaining:
                print(f"  Warning: Directory {dir_name} not empty: {remaining}")
                return

            os.rmdir(directory)
            print(f"  Removed directory: {dir_name}")
            return
        except PermissionError:
            # On Windows, try using rmdir command as fallback
            if sys.platform == "win32" and attempt == max_retries // 2:
                try:
                    subprocess.run(
                        ["cmd", "/c", "rmdir", "/s", "/q", directory],
                        check=True,
                        capture_output=True,
                    )
                    if not os.path.exists(directory):
                        print(f"  Removed directory: {dir_name} (via rmdir)")
                        return
                except subprocess.CalledProcessError:
                    pass

            if attempt < max_retries - 1:
                time.sleep(delay)
                delay = min(delay * 1.5, 5.0)  # cap at 5 seconds
            else:
                print(f"  Warning: Could not remove {dir_name} - may be locked by OneDrive")
        except OSError as e:
            if attempt < max_retries - 1:
                time.sleep(delay)
                delay = min(delay * 1.5, 5.0)
            else:
                print(f"  Warning: Could not remove {dir_name}: {e}")


def show_pending_updates():
    """Show all pending updates across all mods directories."""
    has_any = False
    for mods_dir in UPDATE_MODS_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)
        updates_files = list_files(updates_dir)
        old_files = list_files(old_dir)

        if updates_files or old_files:
            has_any = True
            dir_name = os.path.basename(mods_dir)
            print(f"\n{dir_name}:")
            if updates_files:
                print(f"  New versions ({len(updates_files)} files):")
                for f in sorted(updates_files):
                    print(f"    + {f}")
            if old_files:
                print(f"  Old versions ({len(old_files)} files):")
                for f in sorted(old_files):
                    print(f"    - {f}")

    if not has_any:
        print("No pending updates found.")
    return has_any


def commit_updates():
    """Commit all pending updates by moving new versions into main folders."""
    print("\nCommitting updates...")

    for mods_dir in UPDATE_MODS_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from updates into the main folder
        move_files(updates_dir, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates committed successfully.")


def revert_updates():
    """Revert all pending updates by restoring old versions into main folders."""
    print("\nReverting updates (reverting to old versions)...")

    for mods_dir in UPDATE_MODS_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from old back into the main folder
        move_files(old_dir, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates reverted successfully (reverted to old versions).")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Commit or revert pending mod updates.",
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    subparsers.add_parser(
        "status",
        help="Show pending updates",
    )
    subparsers.add_parser(
        "commit",
        help="Apply updates (keep new versions)",
    )
    subparsers.add_parser(
        "revert",
        help="Discard updates (revert to old versions)",
    )

    return parser.parse_args()


def main():
    args = parse_args()

    if args.command is None or args.command == "status":
        show_pending_updates()
    elif args.command == "commit":
        has_files = show_pending_updates()
        if has_files or any_pending_dirs():
            print()
            commit_updates()
    elif args.command == "revert":
        has_files = show_pending_updates()
        if has_files or any_pending_dirs():
            print()
            revert_updates()


if __name__ == "__main__":
    main()
