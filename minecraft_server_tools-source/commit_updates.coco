"""Entry point to commit or revert pending mod updates.

After update_mods.coco runs, it creates:
- {mods_dir}-updates: Contains newly downloaded mod versions
- {mods_dir}-old: Contains old mod versions that were replaced

This script allows you to either:
- commit: Move updates into the main folders (keeping new versions)
- revert: Move old versions back into main folders (reverting to old versions)

In either case, the -updates and -old folders are deleted afterward.
"""
import os
import shutil
import argparse
import time

from minecraft_server_tools.constants import (
    UPDATED_MODS_DIR_SUFFIX,
    OLD_MODS_DIR_SUFFIX,
)
from minecraft_server_tools.update_mods import UPDATE_MODS_DIRS


def get_update_dirs(mods_dir):
    """Return (updates_dir, old_dir) paths for a given mods directory."""
    return (
        mods_dir + UPDATED_MODS_DIR_SUFFIX,
        mods_dir + OLD_MODS_DIR_SUFFIX,
    )


def has_pending_updates(mods_dir):
    """Check if a mods directory has pending updates."""
    updates_dir, old_dir = get_update_dirs(mods_dir)
    return os.path.exists(updates_dir) or os.path.exists(old_dir)


def list_files(directory):
    """List all files in a directory."""
    if not os.path.exists(directory):
        return []
    return [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]


def move_files(src_dir, dst_dir):
    """Move all files from src_dir to dst_dir."""
    if not os.path.exists(src_dir):
        return
    for filename in list_files(src_dir):
        src_path = os.path.join(src_dir, filename)
        dst_path = os.path.join(dst_dir, filename)
        if os.path.exists(dst_path):
            print(f"  Overwriting: {filename}")
            os.remove(dst_path)
        else:
            print(f"  Moving: {filename}")
        shutil.move(src_path, dst_path)


def remove_dir_if_exists(directory, max_retries=5, initial_delay=0.5):
    """Remove a directory if it exists.

    Includes retry logic for Windows file locking issues (e.g., OneDrive sync).
    """
    if not os.path.exists(directory):
        return

    delay = initial_delay
    for attempt in range(max_retries):
        try:
            shutil.rmtree(directory)
            print(f"  Removed directory: {os.path.basename(directory)}")
            return
        except PermissionError as e:
            if attempt < max_retries - 1:
                print(f"  Retry {attempt + 1}/{max_retries}: waiting {delay:.1f}s for {os.path.basename(directory)}...")
                time.sleep(delay)
                delay *= 2  # exponential backoff
            else:
                print(f"  Warning: Could not remove {os.path.basename(directory)} after {max_retries} attempts: {e}")
                print(f"  You may need to manually delete: {directory}")


def show_pending_updates():
    """Show all pending updates across all mods directories."""
    has_any = False
    for mods_dir in UPDATE_MODS_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)
        updates_files = list_files(updates_dir)
        old_files = list_files(old_dir)

        if updates_files or old_files:
            has_any = True
            dir_name = os.path.basename(mods_dir)
            print(f"\n{dir_name}:")
            if updates_files:
                print(f"  New versions ({len(updates_files)} files):")
                for f in sorted(updates_files):
                    print(f"    + {f}")
            if old_files:
                print(f"  Old versions ({len(old_files)} files):")
                for f in sorted(old_files):
                    print(f"    - {f}")

    if not has_any:
        print("No pending updates found.")
    return has_any


def commit_updates():
    """Commit all pending updates by moving new versions into main folders."""
    print("\nCommitting updates...")

    for mods_dir in UPDATE_MODS_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from updates into the main folder
        move_files(updates_dir, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates committed successfully.")


def revert_updates():
    """Revert all pending updates by restoring old versions into main folders."""
    print("\nReverting updates (reverting to old versions)...")

    for mods_dir in UPDATE_MODS_DIRS:
        updates_dir, old_dir = get_update_dirs(mods_dir)

        if not has_pending_updates(mods_dir):
            continue

        dir_name = os.path.basename(mods_dir)
        print(f"\n{dir_name}:")

        # Move files from old back into the main folder
        move_files(old_dir, mods_dir)

        # Remove both -updates and -old directories
        remove_dir_if_exists(updates_dir)
        remove_dir_if_exists(old_dir)

    print("\nUpdates reverted successfully (reverted to old versions).")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Commit or revert pending mod updates.",
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    subparsers.add_parser(
        "status",
        help="Show pending updates",
    )
    subparsers.add_parser(
        "commit",
        help="Apply updates (keep new versions)",
    )
    subparsers.add_parser(
        "revert",
        help="Discard updates (revert to old versions)",
    )

    return parser.parse_args()


def main():
    args = parse_args()

    if args.command is None or args.command == "status":
        show_pending_updates()
    elif args.command == "commit":
        if show_pending_updates():
            print()
            commit_updates()
    elif args.command == "revert":
        if show_pending_updates():
            print()
            revert_updates()


if __name__ == "__main__":
    main()
