import os
import sys
import json
import subprocess
import traceback
import datetime
import time
import argparse
from pprint import pprint
from urllib.parse import unquote
from collections import defaultdict, namedtuple

# Fix Windows console encoding for unicode characters
if sys.stdout.encoding and sys.stdout.encoding.lower() != 'utf-8':
    sys.stdout.reconfigure(errors='replace')
if sys.stderr.encoding and sys.stderr.encoding.lower() != 'utf-8':
    sys.stderr.reconfigure(errors='replace')

import requests

from minecraft_server_tools import sync_mods, google_api
from minecraft_server_tools.constants import (
    COMMENT_JSON,
    MC_VERSION,
    COMPONENT_SEPS,
    NON_NAME_COMPONENT_REGEX,
    NAME_REGEXES_TO_SPACE,
    UPDATE_MODS_GOOGLE_TEMPLATE,
    NON_CURSEFORGE_MODS,
    MODLOADER,
    WRONG_MODLOADERS,
    MOD_PAGE_NAME_SUFFICES,
    CURSEFORGE_NAMES_FILE,
    CURSEFORGE_IDS_CACHE_FILE,
    CURSEFORGE_API_FILE,
    TIMESTAMP_FORMAT_REGEX,
    UPDATED_MODS_DIR_SUFFIX,
    OLD_MODS_DIR_SUFFIX,
    PRINT_DEBUG,
    MAX_DEBUG_RESULTS,
    CURSEFORGE_NAME_ELEMS_TO_STRIP,
    CURSEFORGE_QUERY_TEMPLATES,
    ALWAYS_USE_LATEST_VERSION_FOR_MODS,
    CURSEFORGE_API_RETRIES,
    CURSEFORGE_API_RETRY_DELAY,
    AVOID_FILES_PUBLISHED_WITHIN,
    FIX_MOD_NAMES,
    NO_COMPONENT_SPLIT_MODS,
    USE_ALL_COMPONENTS_MODS,
    CURSEFORGE_CLASS_ID_MODS,
    CURSEFORGE_CLASS_ID_DATAPACKS,
    CURSEFORGE_CLASS_ID_RESOURCE_PACKS,
    DATAPACK_FOLDER_PATHS,
    SERVER_DIR,
    DEDUPLICATE_MODS_NAME,
    DEDUPLICATE_CLIENT_MODS_NAME,
    ver_join,
    ver_split,
)


UPDATE_MODS_DIRS = [
    sync_mods.EXTRA_CLIENT_MODS_DIR,
    sync_mods.EXTRA_MODS_DIR,
    sync_mods.BASE_CLIENT_MODS_DIR,
    sync_mods.BASE_MODS_DIR,
]

UPDATE_DATAPACK_DIRS = DATAPACK_FOLDER_PATHS

UPDATE_DEDUPLICATE_DIRS = [
    os.path.join(SERVER_DIR, DEDUPLICATE_CLIENT_MODS_NAME),
    os.path.join(SERVER_DIR, DEDUPLICATE_MODS_NAME),
]

BEGINNING_OF_TIME = datetime.datetime(1, 1, 1)

# Configuration for different content types (mods vs datapacks)
ContentTypeConfig = namedtuple('ContentTypeConfig', [
    'name',                    # "mod" or "datapack"
    'file_extension',          # ".jar" or ".zip"
    'curseforge_class_ids',    # list of CurseForge classIds to search
    'use_modloader',           # whether to filter by modloader
])

MOD_CONFIG = ContentTypeConfig(
    name="mod",
    file_extension=".jar",
    curseforge_class_ids=[CURSEFORGE_CLASS_ID_MODS],
    use_modloader=True,
)

DATAPACK_CONFIG = ContentTypeConfig(
    name="datapack",
    file_extension=".zip",
    curseforge_class_ids=[CURSEFORGE_CLASS_ID_DATAPACKS, CURSEFORGE_CLASS_ID_RESOURCE_PACKS],
    use_modloader=False,
)


class MissingCurseforgeNameError(KeyError):
    """Exception raised when a CurseForge name mapping is missing."""
    def __init__(self, mod_name, query):
        self.mod_name = mod_name
        self.query = query
        super().__init__(f"No Curseforge name for mod {mod_name!r}; expecting Claude to search for it and add it to curseforge_names.json (suggested search query: {query!r}).")


def get_mod_name(jar_name, silent=None, do_component_splitting=True, use_all_components=False, file_extension=".jar"):
    if silent is None:
        silent = not PRINT_DEBUG

    base_name = jar_name.removesuffix(file_extension)

    if do_component_splitting:
        for sep, min_count in COMPONENT_SEPS:
            components = base_name.split(sep)
            if len(components) > min_count:
                break
        else:
            if not silent:
                print(f"Failed to find components for jar {jar_name!r}.")
            components = [base_name]

        name_cmpnts = []
        for cmpnt in components:
            is_name_cmpnt = NON_NAME_COMPONENT_REGEX.match(cmpnt.lower()) is None
            if is_name_cmpnt:
                name_cmpnts.append(cmpnt)
            elif name_cmpnts and not use_all_components:
                break
        if not name_cmpnts:
            if not silent:
                print(f"Failed to find name component for jar {jar_name!r}.")
            name_cmpnts = [components[0]]
        mod_name = " ".join(name_cmpnts)
    else:
        mod_name = base_name

    for to_space in NAME_REGEXES_TO_SPACE:
        mod_name = to_space.sub(" ", mod_name)

    if not mod_name:
        if not silent:
            print(f"Got empty mod name for jar {jar_name!r}; falling back to no component splitting.")
        return get_mod_name(jar_name, do_component_splitting=False, file_extension=file_extension)

    camel_case_parts = [mod_name[0]]
    prev_is_lower = mod_name[0].islower()
    for c in mod_name[1:]:
        if prev_is_lower and c.isupper():
            camel_case_parts.append("")
        camel_case_parts[-1] += c
        prev_is_lower = c.islower()

    mod_name = " ".join(camel_case_parts)
    while "  " in mod_name:
        mod_name = mod_name.replace("  ", " ")

    mod_name = mod_name.strip().lower()

    if mod_name in NO_COMPONENT_SPLIT_MODS:
        if not silent:
            print(f"Got mod name {mod_name!r}, but it's marked as no component splitting; redoing without component splitting.")
        return get_mod_name(jar_name, do_component_splitting=False, file_extension=file_extension)

    if mod_name in USE_ALL_COMPONENTS_MODS and not use_all_components:
        if not silent:
            print(f"Got mod name {mod_name!r}, but it's marked as use all components; redoing with all components.")
        return get_mod_name(jar_name, use_all_components=True, file_extension=file_extension)

    if not silent:
        print(f"Determined mod name {mod_name!r} for jar {jar_name!r}.")
    return mod_name


def get_curseforge_name(mod_name, jar_name, google=False):
    if mod_name in NON_CURSEFORGE_MODS:
        return None
    query = UPDATE_MODS_GOOGLE_TEMPLATE.format(
        mod_name=mod_name,
        jar_name=jar_name,
        modloader=MODLOADER,
        mc_version=ver_join(MC_VERSION),
        mc_version_2=ver_join(MC_VERSION[:2]),
        mod_page_name_suffix=MOD_PAGE_NAME_SUFFICES[0],
    )
    if not google:
        raise MissingCurseforgeNameError(mod_name, query)
    try:
        while True:
            search_json = google_api.google(query)
            if search_json is None or "error" in search_json and search_json["error"]["errors"][0]["reason"] == "rateLimitExceeded":
                print("WARNING: Google API failed (try waiting or switching API keys).")
                search_json = {"items": []}
                break
            if "items" in search_json:
                break
            print(f"Got no results for query {query!r}.")
            if "spelling" in search_json:
                query = unquote(search_json["spelling"]["correctedQuery"]).replace("+", " ")
                continue
            assert search_json["searchInformation"]["totalResults"] == "0", search_json
            search_json = {"items": []}
            break
        items = search_json["items"]
        curseforge_name = None
        for result in items:
            mod_page = result["title"]
            for suffix in MOD_PAGE_NAME_SUFFICES:
                if mod_page.lower().endswith(suffix.lower()):
                    curseforge_name = clean_curseforge_name(mod_page[:-len(suffix)])
                    break
            if curseforge_name is not None:
                break
            else:
                print(f"Skipping search result {mod_page!r}.")
        if curseforge_name is None:
            print(f"Could not find curseforge name for mod {mod_name!r} in results for query {query!r}:")
            pprint(items[:MAX_DEBUG_RESULTS])
            curseforge_name = query.rsplit(MODLOADER, 1)[0].strip()
        else:
            print(f"Found curseforge name {curseforge_name!r} for mod {mod_name!r} in result {mod_page!r}.")
        print("Verifying found curseforge name using curseforge search...")
        mod = get_curseforge_mod(mod_name, curseforge_name)
        if mod is None:
            raise IOError(f"Could not find curseforge name for mod {mod_name!r}.")
        else:
            return mod["name"]
    except (KeyError, IndexError, AssertionError):
        print(f"ERROR: Invalid search results for mod {mod_name!r} and query {query!r}:")
        pprint(search_json)
        raise


def clean_curseforge_name(curseforge_name):
    old_curseforge_name = None
    while old_curseforge_name != curseforge_name:
        old_curseforge_name = curseforge_name
        for strip_str in CURSEFORGE_NAME_ELEMS_TO_STRIP:
            if curseforge_name.startswith(strip_str):
                curseforge_name = curseforge_name[len(strip_str):]
            if curseforge_name.endswith(strip_str):
                curseforge_name = curseforge_name[:-len(strip_str)]
        curseforge_name = curseforge_name.strip()
    return curseforge_name


def load_curseforge_names():
    if os.path.exists(CURSEFORGE_NAMES_FILE):
        with open(CURSEFORGE_NAMES_FILE, "r") as ids_fobj:
            curseforge_names = COMMENT_JSON.load(ids_fobj)
            if FIX_MOD_NAMES:
                curseforge_names = {get_mod_name(mod_name): curseforge_name for mod_name, curseforge_name in curseforge_names.items()}
            return curseforge_names
    else:
        return {}


def save_curseforge_names(mod_names_to_curseforge_names):
    with open(CURSEFORGE_NAMES_FILE, "w") as ids_fobj:
        json.dump(mod_names_to_curseforge_names, ids_fobj, indent=4)


def load_curseforge_ids_cache():
    """Load the cached curseforge_name -> curseforge_id mappings."""
    if os.path.exists(CURSEFORGE_IDS_CACHE_FILE):
        with open(CURSEFORGE_IDS_CACHE_FILE, "r") as cache_fobj:
            return json.load(cache_fobj)
    else:
        return {}


def save_curseforge_ids_cache(curseforge_ids_cache):
    """Save the curseforge_name -> curseforge_id cache."""
    with open(CURSEFORGE_IDS_CACHE_FILE, "w") as cache_fobj:
        json.dump(curseforge_ids_cache, cache_fobj, indent=4)


def get_curseforge_names_for(mod_names_to_jar_names, google=False):
    all_mod_names_to_curseforge_names = load_curseforge_names()
    found_curseforge_names_to_mod_names = {}
    missing_curseforge_names = []  # collect all missing names first
    try:
        for mod_name in mod_names_to_jar_names:
            if mod_name not in all_mod_names_to_curseforge_names:
                try:
                    curseforge_name = get_curseforge_name(mod_name, mod_names_to_jar_names[mod_name], google=google)
                except MissingCurseforgeNameError as e:
                    missing_curseforge_names.append((e.mod_name, e.query))
                    continue

                # do validation
                if curseforge_name in found_curseforge_names_to_mod_names:
                    raise ValueError(f"resolved multiple mod names to curseforge name {curseforge_name!r}: {found_curseforge_names_to_mod_names[curseforge_name]} and {mod_name}")
                found_curseforge_names_to_mod_names[curseforge_name] = mod_name

                all_mod_names_to_curseforge_names[mod_name] = curseforge_name
    finally:
        save_curseforge_names(all_mod_names_to_curseforge_names)

    # raise error with all missing names at once
    if missing_curseforge_names:
        print(f"\n{'='*60}")
        print("MISSING CURSEFORGE NAME MAPPINGS:")
        print(f"{'='*60}\n")
        for mod_name, query in missing_curseforge_names:
            print(f"{mod_name!r}")
            print(f"\tSuggested search query: {query!r}\n")
        print(f"{'='*60}\n")
        raise KeyError(f"Missing {len(missing_curseforge_names)} Curseforge name mappings; expecting Claude to search for them and add them to curseforge_names.json.")

    # get nulled mods
    requested_mod_names_to_curseforge_names = {}
    nulled_mods = []
    for mod_name in mod_names_to_jar_names:
        curseforge_name = all_mod_names_to_curseforge_names[mod_name]
        if curseforge_name is None:
            nulled_mods.append(mod_name)
            print(f"Skipping mod {mod_name!r} due to explicitly nulled CurseForge name.")
        else:
            requested_mod_names_to_curseforge_names[mod_name] = curseforge_name
    return requested_mod_names_to_curseforge_names, nulled_mods


def get_jar_names(mods_dir, file_extension=".jar"):
    for fname in os.listdir(mods_dir):
        if fname.endswith(file_extension):
            yield fname


def get_mod_names_to_all_jar_names(mods_dir, file_extension=".jar", **kwargs):
    mod_names_to_all_jar_names = defaultdict(list)
    for jar_name in get_jar_names(mods_dir, file_extension=file_extension):
        mod_name = get_mod_name(jar_name, file_extension=file_extension, **kwargs)
        mod_names_to_all_jar_names[mod_name] += [jar_name]
    return mod_names_to_all_jar_names


def get_mod_names_to_jar_names(mods_dir, file_extension=".jar", **kwargs):
    mod_names_to_jar_names = {}
    for jar_name in get_jar_names(mods_dir, file_extension=file_extension):
        mod_name = get_mod_name(jar_name, file_extension=file_extension, **kwargs)
        if mod_name in mod_names_to_jar_names:
            raise ValueError(f"resolved multiple jars to name {mod_name!r}: {mod_names_to_jar_names[mod_name]} and {jar_name}")
        mod_names_to_jar_names[mod_name] = jar_name
    return mod_names_to_jar_names


def run_curseforge_api_cmd(cmd, class_id=None):
    cmd = [str(x) for x in cmd]
    if class_id is not None:
        cmd.append(str(class_id))
    for _ in range(CURSEFORGE_API_RETRIES):
        print(f"Executing curseforge api cmd: {cmd!r}")
        cmd_result = subprocess.run(["node", CURSEFORGE_API_FILE] + cmd, capture_output=True)
        if cmd_result.stderr:
            print(f"\tcurseforge api cmd {cmd!r} failed: {cmd_result.stderr.decode('utf-8')}")
            time.sleep(CURSEFORGE_API_RETRY_DELAY)
        else:
            break
    else:
        raise Exception(f"Curseforge api cmd {cmd!r} failed {CURSEFORGE_API_RETRIES} times.")
    api_result = cmd_result.stdout.decode("utf-8")
    if not api_result:
        print("\tGot no output from curseforge api.")
        return []
    try:
        return json.loads(api_result)
    except json.decoder.JSONDecodeError:
        print("\nERROR: Could not parse curseforge api output:")
        print(api_result)
        raise


def has_bad_modloader(name):
    if any(wrong_modloader.lower() in name.lower() for wrong_modloader in WRONG_MODLOADERS):
        non_wrong_modloader_name = name.lower()
        for wrong_modloader in WRONG_MODLOADERS:
            non_wrong_modloader_name = non_wrong_modloader_name.replace(wrong_modloader.lower(), " ")
        return MODLOADER.lower() not in non_wrong_modloader_name
    return False

def get_matching_mod(results, curseforge_name, mod_name):
    found_mod = None
    valid_modloader_results = []
    for mod in results:
        valid_modloader = not has_bad_modloader(mod["name"])
        if mod["name"] == curseforge_name:
            if not valid_modloader:
                print(f"\tWARNING: found Curseforge mod by name, but it looks like it has an invalid modloader: {curseforge_name}")
            found_mod = mod
            break
        if valid_modloader:
            valid_modloader_results.append(mod)
    if found_mod is None:
        for mod in valid_modloader_results:
            if mod["name"].startswith(curseforge_name):
                found_mod = mod
                break
    if found_mod is None:
        for mod in valid_modloader_results:
            if curseforge_name in mod["name"]:
                found_mod = mod
                break
    if found_mod is None:
        slug_name = mod_name.replace(" ", "").lower()
        for mod in valid_modloader_results:
            if mod["slug"].replace("-", "").lower() == slug_name:
                found_mod = mod
                break
    if found_mod is None:
        core_curseforge_name = get_core_name(curseforge_name)
        if core_curseforge_name:
            for mod in valid_modloader_results:
                if core_curseforge_name in mod["name"]:
                    found_mod = mod
                    break
    if found_mod is not None and found_mod["name"].strip() != curseforge_name:
        print(f"\tWARNING: found Curseforge mod with different name: {curseforge_name!r} -> {found_mod['name']!r}")
    return found_mod


def log_curseforge_results(results, verbose=False):
    if verbose:
        pprint(results[:MAX_DEBUG_RESULTS])
    else:
        pprint([m["name"] for m in results[:MAX_DEBUG_RESULTS]])


get_core_name = get_mod_name$(silent=True)


def get_curseforge_mod(curseforge_name, mod_name, config=MOD_CONFIG):
    core_curseforge_name = get_core_name(curseforge_name)

    # Try each classId in the config
    for class_id in config.curseforge_class_ids:
        seen_queries = set()
        for query_template in CURSEFORGE_QUERY_TEMPLATES:
            query = query_template.format(
                curseforge_name=curseforge_name,
                core_curseforge_name=core_curseforge_name,
                mod_name=mod_name,
            )
            if query in seen_queries:
                continue
            seen_queries.add(query)

            if config.use_modloader:
                modloader_version_results = run_curseforge_api_cmd(["search", query, ver_join(MC_VERSION), MODLOADER], class_id=class_id)
                mod = get_matching_mod(modloader_version_results, curseforge_name, mod_name)
                if mod is not None:
                    return mod
                if PRINT_DEBUG:
                    print(f"\tCould not find mod {curseforge_name!r} in modloader-version-specific results for query {query!r}.")

                modloader_compatible_version_results = run_curseforge_api_cmd(["search", query, ver_join(MC_VERSION[:2]), MODLOADER], class_id=class_id)
                mod = get_matching_mod(modloader_compatible_version_results, curseforge_name, mod_name)
                if mod is not None:
                    return mod
                if PRINT_DEBUG:
                    print(f"\tCould not find mod {curseforge_name!r} in modloader-compatibly-versioned results for query {query!r}.")

            version_results = run_curseforge_api_cmd(["search", query, ver_join(MC_VERSION), ""], class_id=class_id)
            mod = get_matching_mod(version_results, curseforge_name, mod_name)
            if mod is not None:
                return mod
            if PRINT_DEBUG:
                print(f"\tCould not find mod {curseforge_name!r} in version-specific results for query {query!r}.")

            compatible_version_results = run_curseforge_api_cmd(["search", query, ver_join(MC_VERSION[:2]), ""], class_id=class_id)
            mod = get_matching_mod(compatible_version_results, curseforge_name, mod_name)
            if mod is not None:
                return mod
            if PRINT_DEBUG:
                print(f"\tCould not find mod {curseforge_name!r} in compatibly-versioned results for query {query!r}.")

            if config.use_modloader:
                modloader_results = run_curseforge_api_cmd(["search", query, "", MODLOADER], class_id=class_id)
                mod = get_matching_mod(modloader_results, curseforge_name, mod_name)
                if mod is not None:
                    return mod
                if PRINT_DEBUG:
                    print(f"\tCould not find mod {curseforge_name!r} in modloader-versioned results for query {query!r}.")

            versionless_results = run_curseforge_api_cmd(["search", query, "", ""], class_id=class_id)
            mod = get_matching_mod(versionless_results, curseforge_name, mod_name)
            if mod is not None:
                return mod
            if PRINT_DEBUG:
                print(f"\tCould not find mod {curseforge_name!r} in version-less results for query {query!r}.")

    print(f"\nERROR: Failed to find mod {curseforge_name!r} in any results.\n")


def get_curseforge_id(curseforge_name, mod_name, **kwargs):
    mod = get_curseforge_mod(curseforge_name, mod_name, **kwargs)
    if mod is not None:
        return mod["id"]


def get_mod_names_to_curseforge_ids(mod_names_to_curseforge_names, **kwargs):
    curseforge_ids_cache = load_curseforge_ids_cache()
    mod_names_to_curseforge_ids = {}
    missing_mods = []
    try:
        for mod_name, curseforge_name in mod_names_to_curseforge_names.items():
            # Check cache first
            if curseforge_name in curseforge_ids_cache:
                curseforge_id = curseforge_ids_cache[curseforge_name]
                print(f"Using cached CurseForge ID for {curseforge_name!r}.")
            else:
                curseforge_id = get_curseforge_id(curseforge_name, mod_name, **kwargs)
                if curseforge_id is not None:
                    curseforge_ids_cache[curseforge_name] = curseforge_id

            if curseforge_id is None:
                missing_mods.append(mod_name)
            else:
                mod_names_to_curseforge_ids[mod_name] = curseforge_id
    finally:
        save_curseforge_ids_cache(curseforge_ids_cache)
    return mod_names_to_curseforge_ids, missing_mods


def get_curseforge_files(curseforge_id) =
    run_curseforge_api_cmd(["getfiles", curseforge_id])


def get_curseforge_file_time(curseforge_file, mod_name):
    timestamp = curseforge_file["fileDate"]
    match_results = TIMESTAMP_FORMAT_REGEX.match(timestamp)
    if match_results is None:
        raise ValueError(f"failed to parse timestamp {timestamp!r}")
    parsed_time = datetime.datetime(*(int(match_results[i]) for i in range(1, 7)))
    if (
        AVOID_FILES_PUBLISHED_WITHIN is not None
        and mod_name not in ALWAYS_USE_LATEST_VERSION_FOR_MODS
        and datetime.datetime.now() - parsed_time < AVOID_FILES_PUBLISHED_WITHIN
    ):
        parsed_time = BEGINNING_OF_TIME
    return parsed_time


def timestamp_sort(curseforge_files) = sorted(
    curseforge_files,
    key=f => get_curseforge_file_time(f, mod_name=None),
    reverse=True,
)


def get_max_version(versions):
    ver_tuples = []
    for ver_str in versions:
        try:
            ver_tuples.append(ver_split(ver_str))
        except ValueError:
            pass
    return max(ver_tuples)


def sort_releases(curseforge_files, mod_name) = sorted(
    curseforge_files,
    key=f => (
        get_max_version(f["gameVersions"]),
        (
            0 if mod_name in ALWAYS_USE_LATEST_VERSION_FOR_MODS
            else -f["releaseType"]
        ),
        get_curseforge_file_time(f, mod_name),
    ),
    reverse=True,
)


def best_release(curseforge_files, mod_name) =
    sort_releases(curseforge_files, mod_name)[0]


def reconstruct_curseforge_download_url(curseforge_file):
    """Reconstruct download URL from file ID when downloadUrl is None."""
    file_id = curseforge_file["id"]
    filename = curseforge_file["fileName"]
    first_part = file_id // 1000
    second_part = file_id % 1000
    return f"https://edge.forgecdn.net/files/{first_part}/{second_part}/{filename}"


def get_curseforge_download_url(curseforge_file):
    """Get download URL, reconstructing it if necessary."""
    url = curseforge_file["downloadUrl"]
    if url is None:
        return reconstruct_curseforge_download_url(curseforge_file)
    return url


def get_jar_name_for_curseforge_file(curseforge_file) = (
    get_curseforge_download_url(curseforge_file)
    |> .rsplit("/", 1)
    |> .[-1]
)


def correct_modloader(versions, jar_name=None):
    versions = [v.lower() for v in versions]

    if MODLOADER.lower() in versions:
        return True
    if any(wrong_modloader.lower() in versions for wrong_modloader in WRONG_MODLOADERS):
        return False

    if jar_name is not None:
        jar_name = jar_name.lower()
        if has_bad_modloader(jar_name):
            return False

    return None


def find_curseforge_file_for_jar(curseforge_files, find_jar_name):
    for file_data in curseforge_files:
        jar_name = get_jar_name_for_curseforge_file(file_data)
        if jar_name is not None and are_same_jar(jar_name, find_jar_name):
            return file_data
    return None


def get_latest_version(mod_name, curseforge_id, old_jar_name, config=MOD_CONFIG):
    curseforge_files = get_curseforge_files(curseforge_id)

    old_curseforge_file = find_curseforge_file_for_jar(curseforge_files, old_jar_name)
    if old_curseforge_file is None:
        print(f"WARNING: Could not find curseforge file for existing jar: {old_jar_name}")
    old_file_time = get_curseforge_file_time(old_curseforge_file, mod_name) if old_curseforge_file is not None else BEGINNING_OF_TIME

    curseforge_files_and_versions = []
    for file_data in curseforge_files:
        versions = file_data["gameVersions"]
        jar_name = get_jar_name_for_curseforge_file(file_data)
        modloader_ok = not config.use_modloader or correct_modloader(versions, jar_name) is not False
        if (
            jar_name is not None
            and jar_name.endswith(config.file_extension)
            and modloader_ok
            and get_curseforge_file_time(file_data, mod_name) >= old_file_time
        ):
            curseforge_files_and_versions.append((file_data, versions))

    if config.use_modloader:
        correct_modloader_and_version_files = []
        for file_data, versions in curseforge_files_and_versions:
            if correct_modloader(versions) and ver_join(MC_VERSION) in versions:
                correct_modloader_and_version_files.append(file_data)
        if correct_modloader_and_version_files:
            return best_release(correct_modloader_and_version_files, mod_name)

    correctly_versioned_files = []
    for file_data, versions in curseforge_files_and_versions:
        if ver_join(MC_VERSION) in versions:
            correctly_versioned_files.append(file_data)
    if correctly_versioned_files:
        return best_release(correctly_versioned_files, mod_name)
    print(f"No correctly versioned files found for mod {mod_name!r}.")

    correct_modloader_compatibly_versioned_files = []
    compatibly_versioned_files = []
    for file_data, versions in curseforge_files_and_versions:
        for raw_ver in versions:
            try:
                ver = ver_split(raw_ver)
            except ValueError:
                pass
            else:
                if MC_VERSION[:2] <= ver <= MC_VERSION:
                    if config.use_modloader and correct_modloader(versions):
                        correct_modloader_compatibly_versioned_files.append(file_data)
                    compatibly_versioned_files.append(file_data)
                    break
    if correct_modloader_compatibly_versioned_files:
        return best_release(correct_modloader_compatibly_versioned_files, mod_name)
    if compatibly_versioned_files:
        return best_release(compatibly_versioned_files, mod_name)

    correct_modloader_maybe_compatible_files = []
    maybe_compatible_files = []
    for file_data, versions in curseforge_files_and_versions:
        for ver in versions:
            if ver.startswith(ver_join(MC_VERSION[:2])):
                if config.use_modloader and correct_modloader(versions):
                    correct_modloader_maybe_compatible_files.append(file_data)
                maybe_compatible_files.append(file_data)
                break
    if correct_modloader_maybe_compatible_files:
        return best_release(correct_modloader_maybe_compatible_files, mod_name)
    if maybe_compatible_files:
        return best_release(maybe_compatible_files, mod_name)
    print(f"No compatibly versioned files found for mod {mod_name!r} in:")
    pprint(list(timestamp_sort(curseforge_files))[:MAX_DEBUG_RESULTS])


def are_same_jar(jar_name_1, jar_name_2) =
    jar_name_1.replace(" ", "+") == jar_name_2.replace(" ", "+")


def get_mod_names_to_latest_versions(mod_names_to_curseforge_ids, mod_names_to_jar_names, **kwargs):
    mod_names_to_latest_versions = {}
    missing_mods = []
    for mod_name, curseforge_id in mod_names_to_curseforge_ids.items():
        jar_name = mod_names_to_jar_names[mod_name]
        latest_version = get_latest_version(mod_name, curseforge_id, jar_name, **kwargs)
        if latest_version is None:
            missing_mods.append(mod_name)
        else:
            mod_names_to_latest_versions[mod_name] = latest_version
    return mod_names_to_latest_versions, missing_mods


def get_updated_mod_names_to_files(mod_names_to_jar_names, mod_names_to_latest_versions):
    updated_mod_names_to_files = {}
    for mod_name, latest_file in mod_names_to_latest_versions.items():
        old_jar = mod_names_to_jar_names[mod_name]
        new_jar = get_jar_name_for_curseforge_file(latest_file)
        if new_jar is not None and not are_same_jar(new_jar, old_jar):
            updated_mod_names_to_files[mod_name] = latest_file
    return updated_mod_names_to_files


def download_file(curseforge_file, updated_mods_dir, mod_name):
    jar_name = get_jar_name_for_curseforge_file(curseforge_file)
    assert jar_name is not None, f"cannot download from curseforge file: {curseforge_file!r}"
    url = get_curseforge_download_url(curseforge_file)
    new_jar_path = os.path.join(updated_mods_dir, jar_name)
    if os.path.exists(new_jar_path):
        print(f"WARNING: attempting to redownload existing jar {jar_name!r}")
    else:
        print(f"Downloading {jar_name}...")
        new_mod_name = get_mod_name(jar_name, silent=True)
        if new_mod_name != mod_name:
            print(f"\tWARNING: new mod name: {mod_name!r} -> {new_mod_name!r}")
        result = requests.get(url)
        with open(new_jar_path, "wb") as jar_fobj:
            jar_fobj.write(result.content)


def update_files(updated_mod_names_to_files, updated_mods_dir):
    seen_jar_names = {}
    for mod_name, curseforge_file in updated_mod_names_to_files.items():
        jar_name = get_jar_name_for_curseforge_file(curseforge_file)
        assert jar_name is not None, f"cannot update using curseforge file: {curseforge_file!r}"
        if jar_name in seen_jar_names:
            print(f"\nWARNING: resolved multiple mod names to same jar name {jar_name!r}: {seen_jar_names[jar_name]!r} and {mod_name!r}\n")
        else:
            seen_jar_names[jar_name] = mod_name
        download_file(curseforge_file, updated_mods_dir, mod_name)


def move_old_files(updated_mod_names_to_files, mod_names_to_jar_names, mods_dir, old_mods_dir):
    for mod_name in updated_mod_names_to_files:
        jar_name = mod_names_to_jar_names[mod_name]
        current_jar_path = os.path.join(mods_dir, jar_name)
        new_jar_path = os.path.join(old_mods_dir, jar_name)
        os.rename(current_jar_path, new_jar_path)


def make_dirs(*dirs):
    for d in dirs:
        if not os.path.exists(d):
            os.mkdir(d)


def update_mods(mods_dir, updated_mods_dir, old_mods_dir, dry_run=False, interact=None, google=False, config=MOD_CONFIG):
    if interact is None and not PRINT_DEBUG:
        interact = False
    try:
        mod_names_to_jar_names = get_mod_names_to_jar_names(mods_dir, file_extension=config.file_extension)
        mod_names_to_curseforge_names, nulled_mods = get_curseforge_names_for(mod_names_to_jar_names, google=google)
        if not dry_run:
            mod_names_to_curseforge_ids, missing_ids_mods = get_mod_names_to_curseforge_ids(mod_names_to_curseforge_names, config=config)
            mod_names_to_latest_versions, missing_files_mods = get_mod_names_to_latest_versions(mod_names_to_curseforge_ids, mod_names_to_jar_names, config=config)
            updated_mod_names_to_files = get_updated_mod_names_to_files(mod_names_to_jar_names, mod_names_to_latest_versions)
            if updated_mod_names_to_files:
                make_dirs(updated_mods_dir, old_mods_dir)
                update_files(updated_mod_names_to_files, updated_mods_dir)
                move_old_files(updated_mod_names_to_files, mod_names_to_jar_names, mods_dir, old_mods_dir)
        else:
            missing_ids_mods = []
            missing_files_mods = []
        return nulled_mods + missing_ids_mods + missing_files_mods
    except Exception:
        if interact is not False:
            traceback.print_exc()

            from coconut import \embed
            embed()
        raise
    if interact:
        from coconut import \embed
        embed()


def update_all(mods_dirs, config=MOD_CONFIG, **kwargs):
    couldnt_update = []
    for mods_dir in mods_dirs:
        if not os.path.exists(mods_dir):
            print(f"Skipping non-existent directory: {mods_dir}")
            continue
        updated_mods_dir = mods_dir + UPDATED_MODS_DIR_SUFFIX
        old_mods_dir = mods_dir + OLD_MODS_DIR_SUFFIX
        couldnt_update += update_mods(mods_dir, updated_mods_dir, old_mods_dir, config=config, **kwargs)
    config_name = config.name if kwargs.get("config") is not None else "mod"
    for mod_name in couldnt_update:
        print(f"Unable to automatically update {config_name}: {mod_name}")


def parse_args():
    parser = argparse.ArgumentParser(
        description="Update mods and datapacks from CurseForge to their latest versions.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Only check for missing CurseForge name mappings without downloading updates",
    )
    parser.add_argument(
        "--google",
        action="store_true",
        help="Use Google search to find CurseForge names for unknown mods",
    )
    parser.add_argument(
        "--mods-only",
        action="store_true",
        help="Only update mods, skip datapacks",
    )
    parser.add_argument(
        "--datapacks-only",
        action="store_true",
        help="Only update datapacks, skip mods",
    )
    parser.add_argument(
        "--update-only-deduplicate",
        action="store_true",
        help="Update deduplicate directories instead of normal mod directories",
    )
    return parser.parse_args()


def main():
    args = parse_args()

    sync_mods.main()

    # Just update deduplicate dirs if --update-only-deduplicate
    if args.update_only_deduplicate:
        print("\n" + "="*60)
        print("UPDATING DEDUPLICATE DIRECTORIES")
        print("="*60 + "\n")
        update_all(
            UPDATE_DEDUPLICATE_DIRS,
            dry_run=args.dry_run,
            google=args.google,
            config=MOD_CONFIG,
        )
        return

    # Update mods (unless --datapacks-only)
    if not args.datapacks_only:
        print("\n" + "="*60)
        print("UPDATING MODS")
        print("="*60 + "\n")
        update_all(
            UPDATE_MODS_DIRS,
            dry_run=args.dry_run,
            google=args.google,
            config=MOD_CONFIG,
        )

    # Update datapacks (unless --mods-only or --update-only-deduplicate)
    if not args.mods_only and not args.only_update_deduplicate:
        print("\n" + "="*60)
        print("UPDATING DATAPACKS")
        print("="*60 + "\n")
        update_all(
            UPDATE_DATAPACK_DIRS,
            dry_run=args.dry_run,
            google=args.google,
            config=DATAPACK_CONFIG,
        )


if __name__ == "__main__":
    main()
